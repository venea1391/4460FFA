<!DOCTYPE html>
<html>
<meta charset="utf-8">
<head>
	<title>Yeah Title</title>
	<script src="http://d3js.org/d3.v3.min.js"></script>
	<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
	<style>

	body {
	  font: 10px sans-serif;
	}

	.axis path,
	.axis line {
	  fill: none;
	  stroke: #000;
	  shape-rendering: crispEdges;
	}

	.foreground path {
		fill: none;
		/*stroke: steelblue;*/
		stroke-opacity: .8;
		stroke-width:2;
	}

	.axis text, .sublegend text, .legend text{
		cursor: pointer;
	}

	.TOS {stroke:#1f77b4;}
	.TNG {stroke:#ff7f0e;}
	.DS9 {stroke:#2ca02c;}
	.VOY {stroke:#d62728;}
	.ENT {stroke:#9467bd;}

	.season1 {stroke:#1f77b4;}
	.season2 {stroke:#ff7f0e;}
	.season3 {stroke:#2ca02c;}
	.season4 {stroke:#d62728;}
	.season5 {stroke:#9467bd;}
	.season6 {stroke:#8c564b;}
	.season7 {stroke:#e377c2;}

	</style>
</head>
<body>
<script>

var m = [50, 50, 50, 40], // top right bottom left
    w = 960 - m[1] - m[3], // width
    h = 500 - m[0] - m[2]; // height

var x = d3.scale.ordinal().rangePoints([0, w], 1);
    y = {},
    duration = 750,
    delay = 100;

var line = d3.svg.line(),
    axis = d3.svg.axis().orient("left"),
    background,
    foreground,
    series,
    g;

var legend,
	sublegend;

//sets the values of all the nodes (episodes) to their rating
// var hierarchy = d3.layout.partition()
//     .value(function(d) { return d.rating; });

var color = d3.scale.category10();


var svg = d3.select("body").append("svg:svg")
    .attr("width", w + m[1] + m[3]) //960
    .attr("height", h + m[0] + m[2])  //500
	.append("svg:g")
    .attr("transform", "translate(" + m[3] + "," + m[0] + ")");

d3.json("../KateriWork/hierarchy.json", function(d) {
	assignAvgValue(d);
	// console.log(dimensions);
	series = getSeries(d);
	seasonLevel(d);
});

function seasonLevel(d){
	x.domain(dimensions=longestSeasons(d));
	for (var i = 0; i<dimensions.length; i++){
		y[dimensions[i]] = d3.scale.linear().domain([6, 9]).range([h, 0]);
	}
	// legend
	legend = svg.selectAll("g.legend")
	  .data(series)
	  .enter().append("svg:g")
	  .attr("class", "legend")
	  .attr("transform", function(s, i) { return "translate("+w+"," + (i * 20 ) + ")"; });

	legend.append("svg:line")
	  .attr("class", String)
	  .attr("x1", -7)
	  .attr("x2", 8)
	  .attr("stroke-width", 2);

	legend.append("svg:text")
	  .attr("x", 12)
	  .attr("dy", ".31em")
	  .text(function(s) { return s; })
	  .on("click",seriesNo);

	// displayed path
	foreground = svg.append("svg:g")
	  .attr("class", "foreground")
	  .selectAll("path")
	  .data(series)
	  .enter().append("svg:path")
	  .attr("d", flatPath)
	  .attr("class",function(s){return s})
	  .style("opacity", 0);

	// path enter animation
	foreground.transition()
      .duration(duration)
      .delay(duration/2)
      .style("opacity", 1)
      .attr("d", path);

    // dimension position
	g = svg.selectAll(".dimension")
	  .data(dimensions)
	  .enter().append("svg:g")
	  .attr("class", "dimension")
	  .attr("transform", function() {return "translate(" + m[3] + ")"; })
	  .style("opacity",0.5);

	// Add an axis and title.
	g.append("svg:g")
	  .attr("class", "axis")
	  .each(function(d) { d3.select(this).call(axis.scale(y[d]).ticks(4)); })
	  .append("svg:text")
	  .attr("text-anchor", "middle")
	  .attr("x",-10)
	  .attr("y", h+20)
	  .text(String)
	  .on("click",seasonNumber);//function(){exit();});

	// dimension transaction
	g.transition()
	  .duration(duration)
	  .attr("transform", function(d) {return "translate(" + x(d) + ")"; })
	  .style("opacity",1);

	function path(s) {
		return line(dimensions.map(function(p) {
			// console.log(y[p](getScore(d,s,p)));
			return [x(p), y[p](getScore(d,s,p))];
		}));
	}

	function seasonNumber(tmp,i){
		exit();
		episodeLevel(d,i);
	}

	function seriesNo(tmp,i){
		exit();
		seriesLevel(d,i);
	}
}

function episodeLevel(d,season){
	// console.log(d,season);
	x.domain(dimensions=longestEpisodes(d,season));
	for (var i = 0; i<dimensions.length; i++){
		y[dimensions[i]] = d3.scale.linear().domain([0, 10]).range([h, 0]);
	}

	var seasonData = [season];

	legend = svg.selectAll("g.legend")
	  .data(series)
	  .enter().append("svg:g")
	  .attr("class", "legend")
	  .attr("transform", function(s, i) { return "translate("+w+"," + (i * 20 ) + ")"; });

	legend.append("svg:line")
	  .attr("class", String)
	  .attr("x1", -7)
	  .attr("x2", 8)
	  .attr("stroke-width", 2);

	legend.append("svg:text")
	  .attr("x", 12)
	  .attr("dy", ".31em")
	  .text(function(s) { return s; })
	  .on("click",seriesNo);

	// season Label
	sublegend = svg.selectAll("g.sublegend")
	  .data(seasonData)
	  .enter().append("svg:g")
	  // .style("opacity",0)
	  .attr("class", "sublegend")
	  .attr("transform", function() { return "translate("+(season*124.28600 + 19)+"," + 420 + ")"; });

	sublegend.append("svg:text")
	  .attr("x", 12)
	  .text(function(s) {return "Season "+(s+1); })
	  .on("click",function(){exit();seasonLevel(d)});

	sublegend.transition()
	  .duration(duration)
	  .attr("transform", function() { return "translate("+(w-20)+"," + h + ")"; });

	// displayed path
	foreground = svg.append("svg:g")
	  .attr("class", "foreground")
	  .selectAll("path")
	  .data(series)
	  .enter().append("svg:path")
	  .attr("d", flatPath)
	  .attr("class",function(s){return s})
	  .style("opacity", 0);

	// path enter animation
	foreground.transition()
      .duration(duration)
      .delay(duration/2)
      .style("opacity", 1)
      .attr("d", path);

    // dimension position
	g = svg.selectAll(".dimension")
	  .data(dimensions)
	  .enter().append("svg:g")
	  .attr("class", "dimension")
	  .attr("transform", function() {return "translate(" + m[3] + ")"; })
	  .style("opacity",0.5);

	// Add an axis and title.
	g.append("svg:g")
	  .attr("class", "axis")
	  .each(function(d) { d3.select(this).call(axis.scale(y[d]).ticks(5)); })
	  .append("svg:text")
	  .attr("text-anchor", "middle")
	  .attr("x",-10)
	  .attr("y", h+20)
	  .attr("class","no-pointer")
	  .text(String)
	  .on("click",function(){exit();seasonLevel(d)});

	// dimension transaction
	g.transition()
	  .duration(duration)
	  .attr("transform", function(d) {return "translate(" + x(d) + ")"; })
	  .style("opacity",1);

	function path(s) {
		return line(dimensions.map(function(p) {
			// console.log(y[p](getScore(d,s,p)));
			return [x(p), y[p](getEpisodeScore(d,s,season,p))];
		}));
	}

	function seriesNo(tmp,i){
		exit();
		seriesLevel(d,i);
	}
}

function seriesLevel(d,seriesNumber){
	x.domain(dimensions=longestEpisodesInSeries(d,seriesNumber));
	for (var i = 0; i<dimensions.length; i++){
		y[dimensions[i]] = d3.scale.linear().domain([0, 10]).range([h, 0]);
	}

	svg.selectAll(".legend").remove();

	var seriesData = [seriesNumber];

	var seasonData = seasonsInSeries(d,seriesNumber);

	// legend
	legend = svg.selectAll("g.legend")
	  .data(seasonData)
	  .enter().append("svg:g")
	  .attr("class", "legend")
	  .attr("transform", function(s, i) { return "translate("+(w-7)+"," + (i * 20 ) + ")"; });

	legend.append("svg:line")
	  .attr("class", function(s){ return "season"+(s+1); })
	  .attr("x1", -4)
	  .attr("x2", 9)
	  .attr("stroke-width", 2);

	legend.append("svg:text")
	  .attr("x", 12)
	  .attr("dy", ".31em")
	  .text(function(s) { return "Season "+(s+1); })
	  .on("click",seasonNumber);

	// displayed path
	foreground = svg.append("svg:g")
	  .attr("class", "foreground")
	  .selectAll("path")
	  .data(seasonData)
	  .enter().append("svg:path")
	  .attr("d", flatPath)
	  .attr("class",function(s){return "season"+(s+1);})
	  .style("opacity", 0);

	// path enter animation
	foreground.transition()
      .duration(duration)
      .delay(duration/2)
      .style("opacity", 1)
      .attr("d", path);

    // dimension position
	g = svg.selectAll(".dimension")
	  .data(dimensions)
	  .enter().append("svg:g")
	  .attr("class", "dimension")
	  .attr("transform", function() {return "translate(" + m[3] + ")"; })
	  .style("opacity",0.5);

	// Add an axis and title.
	g.append("svg:g")
	  .attr("class", "axis")
	  .each(function(d) { d3.select(this).call(axis.scale(y[d]).ticks(5)); })
	  .append("svg:text")
	  .attr("text-anchor", "middle")
	  .attr("x",-10)
	  .attr("y", h+20)
	  .attr("class","no-pointer")
	  .text(String)
	  .on("click",function(){exit();seasonLevel(d)});

	// dimension transaction
	g.transition()
	  .duration(duration)
	  .attr("transform", function(d) {return "translate(" + x(d) + ")"; })
	  .style("opacity",1);

    function path(season){
    	return line(dimensions.map(function(p) { //p is episode
			// console.log(getEpisodeScore(d,series[seriesNumber],season,p));
			return [x(p), y[p](getEpisodeScore(d,series[seriesNumber],season,p))];
		}));
    }

    function seasonNumber(tmp,i){
		exit();
		episodeLevel(d,i);
	}
}

function exit(){
	// path exit transition
	foreground.transition()
      .duration(duration)
      .style("opacity", 0);
    // axis transition
    g.transition()
      .duration(duration)
      .delay(duration/2)
      .attr("transform", function() {return "translate(" + m[3] + ")"; })
      .style("opacity",0);
    //remove elements
    svg.selectAll(".dimension").remove();
    svg.selectAll(".foreground").remove();
    svg.selectAll(".sublegend").remove();
    svg.selectAll(".legend").remove();
}

function flatPath(){
	return line(dimensions.map(function(p){
		return [x(p),400];
	}));
}

function getScore(d,s,p){
	//assume d is root
	for (var i = 0; i < d.children.length; i++) {
		if (d.children[i].name == s){
			// console.log(d.children[i].name,s);
			for (var j = 0; j < d.children[i].children.length; j++) {
				// console.log(d.children[i].children[j].name,p);
				if (d.children[i].children[j].name == p){
					// console.log(d.children[i].children[j].value);
					return d.children[i].children[j].value;
					break;
				}
			}
		}
	}
	// return 0;
}

function getEpisodeScore(d,s,season,p){
	// if (p==0 && s=="TOS"){
	// 	return d.children[0].children[season].children[0].value;
	// }
	for (var i = 0; i < d.children.length; i++) {
		if (d.children[i].name == s){
			// console.log(d.children[i].children.length, season);
			if (d.children[i].children.length > season){
				// console.log(d.children[i].children[season].children[j].value);
				var j = (s=="TOS"?p:p-1);
				if (d.children[i].children[season].children.length > j){
					return d.children[i].children[season].children[j].value;
					break;
				}
			}
		}
	}
}

function getSeries(d){
	// assume d is root
	var s = [];
	for (var i = 0; i < d.children.length; i++) {
		s.push(d.children[i].name);
	}
	return s;
}

function seasonsInSeries(d,seriesNumber){
	// assume d is root
	var result = [];
	for (var i = 0; i < d.children[seriesNumber].children.length; i++) {
		result.push(i); //d.children[seriesNumber].children[i].name
	}
	return result;
}

function longestSeasons(d){
	// assume d is root
	var maxLength = -1,index = -1;
	var result = [];
	for (var i=0; i<d.children.length;i++){
		if (d.children[i].children.length > maxLength){
			maxLength = d.children[i].children.length;
			index = i;
		}
	}
	if (index>-1){
		for (var i = 0; i < d.children[index].children.length; i++) {
			result.push(d.children[index].children[i].name);
		};
	}
	return result;
}

function longestEpisodes(d,season){
	// assume d is root
	var maxLength = -1;
	var result = [];
	for (var i = 0; i < d.children.length; i++) {
		if (d.children[i].children.length > season){
			if (d.children[i].children[season].children.length > maxLength){
				maxLength = d.children[i].children[season].children.length;
			}
		}
	}
	if (maxLength > -1){
		for (var i = 1; i < maxLength; i++) {
			result.push(i);
		}
	}
	return result;
}

function longestEpisodesInSeries(d,seriesNumber){
	var maxLength = -1;
	var result = [];
	for (var i = 0; i < d.children[seriesNumber].children.length; i++) {
		if (d.children[seriesNumber].children[i].children.length > maxLength){
			maxLength = d.children[seriesNumber].children[i].children.length;
		}
	}
	if (maxLength > -1){
		for (var i = 1; i < maxLength; i++) {
			result.push(i);
		}
	}
	return result;
}

function assignAvgValue(d){
	var average = 0;
	if(d.children){
		// d.value = avgValues(d);
		for (var i=0; i<d.children.length; i++){
			// assignAvgValue(d.children[i]);
			average += assignAvgValue(d.children[i]);
		}
		average = average/d.children.length;
		d.value = average;
	}
	else{
		average = parseFloat(d.rating);
		d.value = average;
	}
	return average;
}

/* deprecated
*/
function avgValues(d) {
	var average = 0;
	if (d.children){
		for (var i=0; i<d.children.length; i++){
			// console.log(d.children[i]);
			average += avgValues(d.children[i]);
			// console.log(average);
		}
		average = average/d.children.length;
		// console.log('node: '+d.name+'new value: '+average);
	}
	else {average = parseFloat(d.rating)}  //d has no children
	return average;
}
</script>
</body>
</html>