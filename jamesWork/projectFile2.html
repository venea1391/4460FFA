<!DOCTYPE html>
<meta charset="utf-8">
<style>
text {
  font: 10px sans-serif;
}

line {
  stroke: #000;
  stroke-width: 1.5px;
}

circle {
  stroke: #fff;
  stroke-width: 1.5px;
  cursor: pointer;
}

</style>
<body>
<button type="button" onclick="test()">Click Me 1!</button>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script>
var inData;
var csvData;

d3.csv("startrekStrictNoComma.csv",function(data){
	console.log("Loading CSV Data");
	csvData = data;
});

d3.json("data.json",function(error,data){
	console.log("Loading JSON Data");
	inData = data;
});

function episodeRegrab(episodeNode, flag){
	console.log("THIS IS THE EPISODE YOU ARE LOOKING AT (SHOULD BE)");
	console.log(episodeNode);
	console.log(csvData[episodeNode.exact-1]);
	var epData = csvData[episodeNode.exact-1];
	var seriesIndex;
	if(epData.series=="TOS"){
		seriesIndex = 0;
	}
	else if(epData.series=="TNG"){
		seriesIndex = 1;
	}
	else if(epData.series=="DS9"){
		seriesIndex = 2;
	}
	else if(epData.series=="VOY"){
		seriesIndex = 3;
	}
	else if(epData.series=="ENT"){
		seriesIndex = 4;
	}
	if(flag==1){
		return inData.nodes[seriesIndex];
	}
	else if(flag==2){
		return inData.nodes[seriesIndex].children[epData.season-1];
	}
}

function dataRegrab(data,flag){
	if(flag==0){
		return inData;
	}
	else if(flag==1){
		return inData.nodes[data.parentIndex-1];
	}
}

function test(){
	render(inData,0);
}
//method that takes in data and flag to determin amout of nodes that will be needed (plus 1 to account for root)
function generateCount(data, flag){
	if(flag==0){
		return data.nodes.length + 1;
	}
	else if(flag == 1 || flag == 2){
		return data.children.length +1;
	}
	else if(flag == 3){
		return 5;
	}
}

//generates nodes based on inutt data
function generateNodes(data, flag){
	var toRet = [];
	if(flag==0){ //top level
		toRet.push({"name":"Star Trek"});
		$.each(data.nodes, function(i,d){
			toRet.push(d);
		});
		return toRet;
	}
	else if(flag==1 || flag==2){ //series and season level
		toRet.push(data);
		$.each(data.children, function(i,d){
			toRet.push(d);
		});
		return toRet;
	}
	else if(flag == 3){ //episode level
		var episodeData = csvData[data.exact-1];
		toRet.push({"name":episodeData.title+" Episode " +episodeData.episode});
		toRet.push({"name":"Series "+episodeData.series});
		toRet.push({"name":"Season "+episodeData.season});
		toRet.push({"name":episodeData.director});
		toRet.push({"name":episodeData.writer});
		return toRet;
	}
}

function render(input, flag){
	d3.select("svg")
		.remove(); ///removes old so you can add new
		
	var width = 960,
		height = 500;

	var n,
		nodes = [], //d3.range(n).map(function() { return {}; }),
		links = []; //d3.range(n).map(function(d) { return {source: 0, target: (d + input) % n}; });
	
	var force = d3.layout.force()
		.nodes(nodes)
		.links(links)
		.linkDistance(100)
		.size([width, height]);

	//console.log("nodes before");
	//console.log(nodes);
	//will need to check what level we are on, in this case just assuming 0
	
	
	
	var inputNodes = generateNodes(input, flag);
	n = generateCount(input, flag);
	
	//push nodes into force layout
	$.each(inputNodes, function(i,d){
		nodes.push(d);
		if(i!=0){
			links.push({source: 0, target: i});
		}
	});
	
	
	//seting all the nodes to have specific X's and Y's still needs to be fixed
	nodes.forEach(function(d, i) {
		if(i!=0){
			d.x = d.x*i;
			d.y = d.y*i;
		}else{
			d.x = width/2;
			d.y = height/2;
			d.fixed = true;
		}
	});
	
	
	
	//console.log("nodes after");
	//console.log(nodes);

	var svg = d3.select("body").append("svg")
		.attr("width", width)
		.attr("height", height);

	var loading = svg.append("text")
		.attr("x", width / 2)
		.attr("y", height / 2)
		.attr("dy", ".35em")
		.style("text-anchor", "middle")
		.text("Simulating. One moment please…");

	// Use a timeout to allow the rest of the page to load first.
	setTimeout(function() {

	  // Run the layout a fixed number of times.
	  // The ideal number of times scales with graph complexity.
	  // Of course, don't run too long—you'll hang the page!
	  force.start();
	  for (var i = n * n*n; i > 0; --i) force.tick();
	  force.stop();

	  svg.selectAll("line")
		  .data(links)
		.enter().append("line")
		  .attr("x1", function(d) { return d.source.x; })
		  .attr("y1", function(d) { return d.source.y; })
		  .attr("x2", function(d) { return d.target.x; })
		  .attr("y2", function(d) { return d.target.y; });

	  svg.selectAll("circle")
		  .data(nodes)
		.enter().append("circle")
		  .attr("class", "node")
		  .attr("cx", function(d) { return d.x; })
		  .attr("cy", function(d) { return d.y; })
		  .attr("r", 10)
		.on("mouseover", function(d,i){
			console.log("Index: "+i);
			console.log(d);
			console.log("Mouse over me baby!!!");
		})
		.on("click", function(d,i){
			console.log("You clicked me baby!");
			console.log("Flag: "+flag);
			console.log("Index: "+i);
			if((flag==0 && i==0)||(flag==3 && i==0)){ //Does nothing at top and bottom of treee
				return;
			}
			if(flag==3){
				if(i==1){ //Selected series to go back to
					render(episodeRegrab(input,(1)),1);
					return;
				}
				else if(i==2){ //Selected season to go back to
					render(episodeRegrab(input,(2)),2);
					return;
				}
				else if(i==3){//Selected director TODO
					return;
				}
				else if(i==4){//Selected writer TODO
					return;
				}
			}
			if(i==0){ //Going back!
				render(dataRegrab(d,(flag-1)),(flag-1));
				return;
			}
			render(d, flag+1); //di deeper in a node
		});

	  loading.remove();
	}, 10);
}




</script>